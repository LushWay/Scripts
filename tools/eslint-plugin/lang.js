import fs from 'fs/promises'
import path from 'path'
import { sourceCodeLang, supportedLanguages } from './asset-lang.js'

/** @template T */
class LangWriter {
  /** @type {string} */
  base

  /** @type {(data: Record<string, T>) => string} */
  stringify = data => JSON.stringify(data, null, 2)

  parse = JSON.parse

  /** @type {Record<string, Record<string, T>>} */
  storage = {}

  constructor(base = 'lang') {
    this.base = base
  }

  ext = '.json'

  /** @param {string} lang */
  #path(lang) {
    return path.join(this.base, lang + this.ext)
  }

  readAll() {
    return Promise.all(supportedLanguages.map(e => this.read(e)))
  }

  writeAll() {
    return Promise.all(supportedLanguages.map(e => this.write(e)))
  }

  /**
   * @param {string} lang
   * @param {Record<string, T>} data
   */
  write(lang, data = { ...this.storage[sourceCodeLang], ...this.storage[lang] }) {
    for (const key in data) {
      const value = data[key]
      if (!(key in this.storage[sourceCodeLang]) && !key.startsWith('__UNUSED__')) {
        delete data[key]
        data['__UNUSED__' + key] = value
      } else {
        const expected = this.storage[sourceCodeLang][key]
        if (
          !(
            (typeof value === 'string' && typeof expected === 'string') ||
            (Array.isArray(value) && Array.isArray(expected)) ||
            (typeof value === 'object' && typeof expected === 'object')
          )
        ) {
          console.warn(
            `${this.prefix}: Unexpected type of message with id ${key} for lang ${lang}`,
            value,
            'expected:',
            expected,
          )
        }
      }
    }
    return fs.writeFile(this.#path(lang), (this.stringify(data) + '\n').replaceAll('\n', '\r\n'), 'utf-8')
  }

  get prefix() {
    return `LangWriter(${this.base}/*.${this.ext})`
  }

  /**
   * @param {string} lang
   * @returns {Promise<Record<string, T>>}
   */
  async read(lang) {
    /** @type {Record<string, T>} */
    let parsed = {}

    try {
      parsed = this.parse(await fs.readFile(this.#path(lang), 'utf-8'))
    } catch (e) {
      console.warn('Unable to read lang', lang, 'with base', this.base, e)
    }

    if (lang === sourceCodeLang) {
      this.storage[lang] = parsed
    } else {
      this.storage[lang] = {
        ...parsed,
        ...(this.storage[lang] ?? {}),
      }
    }

    console.log(`${this.prefix}:`, 'Read', lang, 'with keys', Object.keys(parsed).length)

    return parsed
  }
}
/** @typedef {string | string[] | Record<string, string | string[]>} Message */

/** @type {LangWriter<Message>} */
export const messagesJson = new LangWriter('lang')

/** @type {LangWriter<string>} */
export const sharedMessages = new LangWriter('texts')
sharedMessages.ext = '.lang'
sharedMessages.stringify = data => {
  let t = '### This file is autogenerated, do not edit\n\n'
  for (const k in data)
    t += `${templateToSharedId(k.split('\x00'))}=${data[k].replaceAll('\x00', '%s').replaceAll('\\n', '~LINEBREAK~')}\n`
  return t
}
sharedMessages.parse = () => ({})

export async function readMessages() {
  await sharedMessages.readAll()
  await messagesJson.readAll()
}

/**
 * @template {Record<string, unknown>} T
 * @template {string} K2
 * @template V2
 * @param {T} object
 * @param {(key: keyof T, value: Required<T>[keyof T], object: NoInfer<T>) => [K2, V2] | false} mapper
 * @returns {NoInfer<Record<K2, V2>>}
 */
function map(object, mapper) {
  /** @type {Record<string, unknown>} */
  const result = {}

  for (const key of Object.getOwnPropertyNames(object)) {
    // @ts-expect-error ahahah
    const mapped = mapper(key, object[key], object)
    if (mapped) result[mapped[0]] = mapped[1]
  }
  // @ts-expect-error ahahah
  return result
}

export async function writeMessages() {
  await sharedMessages.writeAll()
  await messagesJson.writeAll()

  await fs.writeFile(
    path.join('src/lib/assets', 'lang-messages.ts'),
    `
/* eslint-ignore */
/* i18n-ignore */
// Autogenerated by translate plugin

type Language = string
type MessageId = string

export const extractedSharedMessagesIds: Record<MessageId, string> = ${JSON.stringify(Object.fromEntries(Object.entries(sharedMessages.storage[sourceCodeLang]).map(e => [e[1], templateToSharedId(e[0].split('\x00'))])), null, 2)}

export const extractedTranslatedMessages: Record<Language, Record<MessageId, readonly string[]>> = ${JSON.stringify(
      map(messagesJson.storage, (k, v) => [
        k,
        map(
          v,
          (k, v) =>
            (typeof v === 'string' || (typeof v === 'object' && Array.isArray(v))) && [k, Array.isArray(v) ? v : [v]],
        ),
      ]),
      null,
      2,
    )}

export const extractedTranslatedPlurals: Record<Language, Record<MessageId, Readonly<Partial<Record<Intl.LDMLPluralRule, string>>>>> = ${JSON.stringify(
      map(messagesJson.storage, (k, v) => [k, map(v, (k, v) => typeof v === 'object' && !Array.isArray(v) && [k, v])]),
      null,
      2,
    )}`,
  )
}

/** @param {string[]} template */
function templateToSharedId(template) {
  return `script.shared.${template.join('$')}`
    .toLowerCase()
    .replace(/§./g, '')
    .replaceAll('\\n', '_')
    .replace(/\s/g, '_')
    .replace(/[^a-zA-Zа-яА-Я.$_0-9]/g, '__')
    .replace(/\.+/g, '.')
}

/**
 * @param {string} id
 * @param {string[]} template
 * @param {boolean} shared
 * @param {boolean} plural
 */
export function addTranslation(id, template, shared, plural) {
  const templ = template.length === 1 ? template[0] : template
  const prev = messagesJson.storage[sourceCodeLang][id]
  if (plural) console.log(id, template, shared, templ, prev)

  const defaultTranslation = insertTranslation(plural, templ, prev, id, sourceCodeLang)

  // Special case handling to add all needed forms of plural to each lang
  if (plural) {
    for (const lang of supportedLanguages) {
      const prev = messagesJson.storage[lang][id]
      if (prev === undefined || (typeof prev === 'object' && !Array.isArray(prev))) {
        insertTranslation(true, template, prev, id, lang)
      } else throw new Error(`Failed to extract plural ${template}: Non plural key already exists`)
    }
  }

  // Add to shared messages
  if (shared || plural) {
    for (const lang of supportedLanguages) {
      const translation = messagesJson.storage[lang][id] ?? defaultTranslation

      /** @param {string[] | string} t */
      function toStr(t) {
        return typeof t === 'string' ? t : t.join('\x00')
      }

      if (typeof translation === 'string') {
        // Simple
        sharedMessages.storage[lang][id] = toStr(translation)
      } else if (Array.isArray(translation)) {
        // Args
        sharedMessages.storage[lang][id] = toStr(translation)
      } else {
        // Plural
        for (const key in translation) sharedMessages.storage[lang][`${id}.${key}`] = toStr(translation[key])
      }
    }
  }
}

const plurals = Object.fromEntries(
  supportedLanguages.map(e => [e, new Intl.PluralRules(e.replace('_', '-')).resolvedOptions().pluralCategories]),
)
/**
 * @param {boolean} plural
 * @param {string[] | string} template
 * @param {Message | undefined} prev
 * @param {string} id
 * @param {string} lang
 * @returns {Message}
 */
function insertTranslation(plural, template, prev, id, lang = sourceCodeLang) {
  /** @type {Message} */
  let t
  if (!plural) t = template
  else {
    const p = Object.fromEntries(plurals[lang].map(e => [e, template]))
    t = { ...(typeof prev === 'object' && !Array.isArray(prev) ? prev : {}), ...p }
  }

  if (!prev) {
    // Insert at the start
    messagesJson.storage[lang] = { [id]: t, ...messagesJson.storage[lang] }
  } else messagesJson.storage[lang][id] = t
  return t
}
