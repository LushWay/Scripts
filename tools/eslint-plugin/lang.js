import fs from 'fs/promises'
import path from 'path'
import { sourceCodeLang, supportedLanguages } from './asset-lang.js'

/** @template T */
class LangWriter {
  /** @type {string} */
  base

  /** @type {(data: Record<string, T>) => string} */
  stringify = data => JSON.stringify(data, null, 2)

  parse = JSON.parse

  /** @type {Record<string, Record<string, T>>} */
  storage = {}

  constructor(base = 'lang') {
    this.base = base
  }

  ext = '.json'

  /** @param {string} lang */
  #path(lang) {
    return path.join(this.base, lang + this.ext)
  }

  readAll() {
    return Promise.all(supportedLanguages.map(e => this.read(e)))
  }

  writeAll() {
    return Promise.all(supportedLanguages.map(e => this.write(e)))
  }

  /**
   * @param {string} lang
   * @param {Record<string, T>} data
   */
  write(lang, data = { ...this.storage[sourceCodeLang], ...this.storage[lang] }) {
    for (const key in data) {
      const value = data[key]
      if (!(key in this.storage[sourceCodeLang]) && !key.startsWith('__UNUSED__')) {
        delete data[key]
        data['__UNUSED__' + key] = value
      } else {
        const expected = this.storage[sourceCodeLang][key]
        if (
          !(
            value === expected ||
            (Array.isArray(value) && Array.isArray(expected)) ||
            (typeof value === 'object' && typeof expected === 'object')
          )
        ) {
          console.warn(
            `${this.prefix}: Unexpected type of message with id ${key} for lang ${lang}`,
            value,
            'expected:',
            expected,
          )
        }
      }
    }
    return fs.writeFile(this.#path(lang), (this.stringify(data) + '\n').replaceAll('\n', '\r\n'), 'utf-8')
  }

  get prefix() {
    return `LangWriter(${this.base}/*.${this.ext})`
  }

  /**
   * @param {string} lang
   * @returns {Promise<Record<string, T>>}
   */
  async read(lang) {
    /** @type {Record<string, T>} */
    let parsed = {}

    try {
      parsed = this.parse(await fs.readFile(this.#path(lang), 'utf-8'))
    } catch (e) {
      console.warn('Unable to read lang', lang, 'with base', this.base, e)
    }

    if (lang === sourceCodeLang) {
      this.storage[lang] = parsed
    } else {
      this.storage[lang] = {
        ...parsed,
        ...(this.storage[lang] ?? {}),
      }
    }

    console.log(`${this.prefix}:`, 'Read', lang, 'with keys', Object.keys(parsed).length)

    return parsed
  }
}
/** @typedef {string | string[] | Record<string, string | string[]>} Message */

/** @type {LangWriter<Message>} */
export const messagesJson = new LangWriter('lang')

/** @type {LangWriter<string>} */
export const sharedMessages = new LangWriter('texts')
sharedMessages.ext = '.lang'
sharedMessages.stringify = data => {
  let t = '### This file is autogenerated, do not edit\n\n'
  for (const k in data)
    t += `${templateToSharedId(k.split('\x00'))}=${data[k].replaceAll('\x00', '%s').replaceAll('\\n', '~LINEBREAK~')}\n`
  return t
}
sharedMessages.parse = () => ({})

export async function readMessages() {
  await sharedMessages.readAll()
  await messagesJson.readAll()
}

export async function writeMessages() {
  await sharedMessages.writeAll()
  await messagesJson.writeAll()

  await fs.writeFile(
    path.join('src/lib/assets', 'lang-messages.ts'),
    `
/* eslint-ignore */
/* i18n-ignore */
// Autogenerated by translate plugin

type Language = string
type MessageId = string

export const extractedSharedMessagesIds: Record<MessageId, string> = ${JSON.stringify(Object.fromEntries(Object.entries(sharedMessages.storage[sourceCodeLang]).map(e => [e[1], templateToSharedId(e[0].split('\x00'))])))}

export const extractedTranslatedMessages: Record<Language, Record<MessageId, readonly string[]>> = ${JSON.stringify(Object.fromEntries(Object.entries(messagesJson.storage).map(e => [e[0], Array.isArray(e[1]) ? e[1] : [e[1]]])))}

export const extractedTranslatedPlurals: Record<Language, Record<MessageId, Readonly<Partial<Record<Intl.LDMLPluralRule, string>>>>> = ${JSON.stringify(
      Object.fromEntries(
        Object.entries(messagesJson.storage)
          .filter(e => typeof e[1] === 'object' && !Array.isArray(e[1]))
          .map(e => [e[0], Array.isArray(e[1]) ? e[1] : [e[1]]]),
      ),
    )}`,
  )
}

/** @param {string[]} template */
function templateToSharedId(template) {
  return `script.shared.${template.join('$')}`
    .toLowerCase()
    .replace(/§./g, '')
    .replaceAll('\\n', '_')
    .replace(/\s/g, '_')
    .replace(/[^a-zA-Zа-яА-Я.$_0-9]/g, '__')
    .replace(/\.+/g, '.')
}

/**
 * @param {string} id
 * @param {string[]} template
 * @param {boolean} shared
 * @param {boolean} plural
 */
export function addTranslation(id, template, shared, plural) {
  const templ = template.length === 1 ? template[0] : template
  /** @type {Message} */
  let t
  if (!plural) t = templ
  else {
    const prev = messagesJson.storage[sourceCodeLang][id]
    t = getPluralForms(prev, sourceCodeLang, templ)
  }
  messagesJson.storage[sourceCodeLang][id] = t

  // Add to shared messages
  if (shared || plural) {
    for (const lang of supportedLanguages) {
      const translation = messagesJson.storage[lang][id] ?? t

      /** @param {string[] | string} t */
      function toStr(t) {
        return typeof t === 'string' ? t : t.join('\x00')
      }

      if (typeof translation === 'string') {
        // Simple
        sharedMessages.storage[lang][id] = toStr(translation)
      } else if (Array.isArray(translation)) {
        // Args
        sharedMessages.storage[lang][id] = toStr(translation)
      } else {
        // Plural
        for (const key in translation) sharedMessages.storage[lang][`${id}.${key}`] = toStr(translation[key])
      }
    }
  }
}

const plurals = Object.fromEntries(
  supportedLanguages.map(e => [e, new Intl.PluralRules(e.replace('_', '-')).resolvedOptions().pluralCategories]),
)

/**
 * @param {Message} prev
 * @param {string} lang
 * @param {string | string[]} fill
 * @returns {Record<string, string | string[]>}
 */
function getPluralForms(prev, lang, fill) {
  const p = Object.fromEntries(plurals[lang].map(e => [e, fill]))
  return { ...(typeof prev === 'object' && !Array.isArray(prev) ? prev : {}), ...p }
}
